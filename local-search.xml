<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go编程</title>
    <link href="/2021/02/19/Golang/"/>
    <url>/2021/02/19/Golang/</url>
    
    <content type="html"><![CDATA[<h1 id="Go起源、发展、普及"><a href="#Go起源、发展、普及" class="headerlink" title="Go起源、发展、普及"></a>Go起源、发展、普及</h1><p><img src="/img/gopher.png" alt="Go 语言设计者：Griesemer、Thompson 和 Pike"></p><p><img src="/img/otherlang.png" alt="其它编程语言对 Go 语言的影响"></p><p><strong>为什么创造Go?</strong></p><ol><li>缺少与时代相符合的系统级编程语言</li><li>要充分利用硬件</li><li>快速编译、高效执行、易于开发</li></ol><p><strong>Go的发展目标</strong></p><ol><li><p>将静态语言的安全性和高效性与动态语言的易开发性结合</p><blockquote><p>类型安全、内存安全，有指针，但不允许指针操作</p></blockquote></li><li><p>支持网络通信、并发并行编程，以更好的利用分布式和多核计算机</p><blockquote><p>goroutine、channel、分段栈增长、goroutine在线程基础上多路复用技术的自动化(select)</p><p>分段栈：栈空间初始大小很小，之后自动增长，从而保证开多个线程或协程而不耗尽内存</p></blockquote></li><li><p>构建速度（编译和链接到机器代码的速度）</p><blockquote><p>主要针对C++</p></blockquote></li><li><p>执行速度、垃圾回收、反射、调用C库</p></li></ol><p><strong>指导设计原则</strong></p><ol><li>减少关键字数量来简化编码的复杂度和混乱度</li><li>只提供一到两个方法解决问题，提高代码可读性</li><li>概念之间相互独立</li></ol><p><strong>语言特性</strong></p><ol><li>天然并发</li><li>没有类和继承的概念，通过接口实现多态</li><li>函数是基本构件</li><li>强静态类型</li><li>支持动态语言的一些特性</li><li>支持交叉编译</li></ol><p><strong>用途</strong></p><p>Web服务器、存储集群、游戏服务器、复杂事件处理(CEP)</p><blockquote><p>不合适实时性要求高的软件（垃圾回收、自动内存分配）</p></blockquote><h1 id="安装Go与运行环境"><a href="#安装Go与运行环境" class="headerlink" title="安装Go与运行环境"></a>安装Go与运行环境</h1><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><strong><code>$GOROOT</code></strong> Go的安装位置，默认<code>$HOME/go</code></p><p><strong><code>$GOBIN</code></strong> 编译器和链接器的安装位置，默认<code>$GOROOT/bin</code></p><p><strong><code>$GOPATH</code></strong> 默认采用<code>$GOROOT</code>，必须以下三个目录</p><ul><li><p><code>src</code> 源码文件</p></li><li><p><code>pkg</code> 包文件</p></li><li><p><code>bin</code> 可执行文件</p></li></ul><p><strong><code>$GOARCH</code></strong> 目标机器的处理器架构(386/amd64/arm)</p><p><strong><code>$GOOS</code></strong> 目标机器的操作系统(Darwin/freebsd/linux/windows)</p><p><strong><code>$GOHOSTARCH</code></strong> <strong><code>$GOHOSTOS</code></strong> 本地机器的处理器架构/操作系统（交叉编译时使用， 默认和目标机器一样）</p><p><strong><code>$GOARM</code></strong> 针对基于arm架构的处理器(5~7, 默认6)</p><p><strong><code>$GOMAXPROCS</code></strong> 设置应用程序可用的处理器个数和核数</p><h2 id="Go运行时"><a href="#Go运行时" class="headerlink" title="Go运行时"></a>Go运行时</h2><p>runtime类似虚拟机，管理内存分配、垃圾回收（清除回收器）、栈处理、goroutine、channel、slice、map、reflection</p><p><code>$GOROOT/src/runtime</code></p><h1 id="语言的核心结构与技术"><a href="#语言的核心结构与技术" class="headerlink" title="语言的核心结构与技术"></a>语言的核心结构与技术</h1><h2 id="程序基本结构和要素"><a href="#程序基本结构和要素" class="headerlink" title="程序基本结构和要素"></a>程序基本结构和要素</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>程序一般由关键字、常量、变量、类型、函数、注释组成</p><h3 id="关键字（25）"><a href="#关键字（25）" class="headerlink" title="关键字（25）"></a>关键字（25）</h3><p><code>import</code> <code>package</code></p><p><code>const</code> <code>var</code> <code>type</code></p><p> <code>map</code> <code>chan</code> <code>struct</code></p><p><code>if</code> <code>else</code>  <code>for</code> <code>range</code> <code>switch</code> <code>case</code> <code>default</code> <code>fallthrough</code> <code>select</code> <code>break</code> <code>continue</code> <code>goto</code></p><p><code>func</code> <code>return</code> <code>defer</code></p><p><code>interface</code></p><p><code>go</code></p><p><strong><code>import/const/var/type</code>可以进行因式分解</strong></p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ol><li>由字母、数字、 下划线组成，不能以数字开头</li><li>区分大小写</li><li>不能使用关键字</li></ol><p>空白标识符<code>_</code>用于舍弃值</p><blockquote><p>赋给<code>_</code>的值之后不能使用，也不能以<code>_</code>为变量对其他变量进行赋值和运算</p></blockquote><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ol><li>文件名：下划线分隔的小写单词</li><li>包名：一个小写单词（不应使用下划线和驼峰），且为源码的基本名称（encoding/base64 -&gt; base64）</li><li>Getters: <code>owenr</code> -&gt; <code>Owner</code>/<code>SetOwner</code></li><li>接口名：只包含一个方法的接口应当以该方法的名称加上 - er 后缀来命名</li><li>约定：驼峰命名</li></ol><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>不要写</p><blockquote><p>词法分析器规则：如果新行前的标记为语句的末尾，则插入分号</p></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释是不会解析的纯文本（不要使用HTML）</p><p>文档注释：包中顶级声明上面的注释（无空行分隔）</p><ol><li><p>每个包应有一段注释</p></li><li><p>每个可导出名应有注释</p></li></ol><p><code>//单行</code></p><p><code>/*多行*/</code></p><h3 id="构建程序"><a href="#构建程序" class="headerlink" title="构建程序"></a>构建程序</h3><ol><li><strong>如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译</strong></li><li><strong>每一段代码只会被编译一次</strong></li></ol><h3 id="程序启动"><a href="#程序启动" class="headerlink" title="程序启动"></a>程序启动</h3><p><img src="/img/2.3.init.png" alt="程序的启动流程"></p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>包是结构化代码的一种方式：每个Go程序都由包这种概念组成，可以使用自身的包以及导入其他包的内容</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><ol><li><p>每个Go文件属于一个包<code>package &lt;pkgName&gt;</code>，每个包可以有多个Go文件</p></li><li><p><strong>包名与导入路径的最后一个元素一致</strong></p></li><li><p>(导入包后)<strong>只能引用导出名</strong></p><blockquote><p>可见性原则</p><ol><li>大写字母开头的变量是可导出的，是公有变量；小写字母开头的是不可导出的，是私有变量</li><li>大写字母开头的函数相当于<code>class</code>中的<code>public</code>函数；小写字母开头的就是<code>private</code>函数</li></ol></blockquote></li><li><p>每个Go应用程序都必须包含一个<code>main</code>包</p><blockquote><p><code> package main</code>表示一个独立可执行的程序</p></blockquote></li></ol><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a><strong>导入</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <br><br><span class="hljs-comment">// 分组导入(推荐) -&gt; 关键字因式分解（同样适用于const/var/type）</span><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>  <span class="hljs-string">&quot;math&quot;</span><br>)<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong>：导入包后不使用会引发错误</p><p><strong>包的分级声明和初始化</strong></p><p><code>import</code>导入包后，定义或声明的<code>var/const/type/func/...</code>都属于包这个作用域</p><p><strong>技巧</strong></p><p>点操作: 省略包名前缀</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span>(<br>  . <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br>Println(<span class="hljs-string">&quot;.&quot;</span>)<br></code></pre></td></tr></table></figure><p>别名操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span>(<br>  f <span class="hljs-string">&quot;fmt&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>_操作： 不使用包的函数，而是调用包的<code>init</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;database/sql&quot;</span><br>_ <span class="hljs-string">&quot;github.com/ziutek/mymysql/godrv&quot;</span><br>)<br></code></pre></td></tr></table></figure><h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><p><code>$GOROOT/pkg/$GOOS_$GOARCH/</code></p><h4 id="所占字节数"><a href="#所占字节数" class="headerlink" title="所占字节数"></a>所占字节数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ArbitraryType <span class="hljs-keyword">int</span><br><br>safe.Sizeof(x ArbitraryType) <span class="hljs-keyword">uintptr</span><br></code></pre></td></tr></table></figure><h4 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h4><p><code>math/rand</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">rand.Seed(seed <span class="hljs-keyword">int64</span>)<span class="hljs-comment">//随机种子，默认 纳秒级时间戳</span><br>rand.Intn(n <span class="hljs-keyword">int</span>)<span class="hljs-comment">// [0, n)之间的整数</span><br>rand.Float32/<span class="hljs-number">64</span>()<span class="hljs-comment">// [0.0, 1.0)之间的浮点数</span><br></code></pre></td></tr></table></figure><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><p><code>unicode</code> <code>unicode/utf8</code>字符的相关操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">unicode.IsLetter(<span class="hljs-keyword">rune</span>) <span class="hljs-keyword">bool</span><br>IsDigit<br>IsSpace<br><br>utf8.RuneCountInString(s <span class="hljs-keyword">string</span>) <span class="hljs-keyword">int</span><br>utf8.RuneCount(b []<span class="hljs-keyword">byte</span>) <span class="hljs-keyword">int</span><br></code></pre></td></tr></table></figure><hr><p><code>strings</code> 字符串的相关操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 前后缀</span><br>strings.HasPrefix(s, prefix <span class="hljs-keyword">string</span>) <span class="hljs-keyword">bool</span><br>strings.HasSuffix(s, suffix <span class="hljs-keyword">string</span>) <span class="hljs-keyword">bool</span><br><br><span class="hljs-comment">// 包含关系</span><br>strings.Contains(s, substr <span class="hljs-keyword">string</span>) <span class="hljs-keyword">bool</span><br><br><span class="hljs-comment">// 索引, -1表示无</span><br>strings.Index(s, str <span class="hljs-keyword">string</span>) <span class="hljs-keyword">int</span><br>strings.LastIndex(s, str <span class="hljs-keyword">string</span>) <span class="hljs-keyword">int</span><br>strings.IndexRune(s <span class="hljs-keyword">string</span>, r <span class="hljs-keyword">rune</span>) <span class="hljs-keyword">int</span><br><br><span class="hljs-comment">// 替换, n = -1表示替换所有</span><br>strings.Replace(s, old, <span class="hljs-built_in">new</span>, n) <span class="hljs-keyword">string</span><br><br><span class="hljs-comment">// 计数</span><br>strings.Count(s, str <span class="hljs-keyword">string</span>) <span class="hljs-keyword">int</span><br><br><span class="hljs-comment">// 重复</span><br>strings.Repeat(s, count <span class="hljs-keyword">int</span>) <span class="hljs-keyword">string</span><br><br><span class="hljs-comment">// 大小写</span><br>strings.ToLower(s) <span class="hljs-keyword">string</span><br>strings.ToUpper(s) <span class="hljs-keyword">string</span><br><br><span class="hljs-comment">// 修剪</span><br>strings.TrimSpace(s)<br>strings.Trim(s, cutset <span class="hljs-keyword">string</span>) <span class="hljs-keyword">string</span><br>strings.TrimLeft<br>strings.TrimRight<br><br><span class="hljs-comment">// 分割</span><br><span class="hljs-comment">// 空白分割, 空串则切片长度为0</span><br>strings.Fields(<span class="hljs-keyword">string</span>) []<span class="hljs-keyword">string</span><br><span class="hljs-comment">// 指定分隔符</span><br>strings.Split(s, sep <span class="hljs-keyword">string</span>) []<span class="hljs-keyword">string</span><br><br><span class="hljs-comment">// 拼接 slice to string with sep</span><br>strings.Join(elems []<span class="hljs-keyword">string</span>, sep <span class="hljs-keyword">string</span>) <span class="hljs-keyword">string</span><br><br><span class="hljs-comment">// 从字符串中读取数据</span><br>strings.NewReader(<span class="hljs-keyword">string</span>) *Reader<br>  Read() []<span class="hljs-keyword">byte</span><br>  ReadByte() <span class="hljs-keyword">byte</span><br>  ReadRune() <span class="hljs-keyword">rune</span><br></code></pre></td></tr></table></figure><hr><p><code>strconv</code> 字符串与其他类型的转换(任何类型转换成字符串总是成功的，字符串转成其他类型不一定成功)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 程序运行时，操作系统的int所占位数</span><br>strconv.IntSize<br>----------------------------------------------------------------------------------------<br><br><span class="hljs-comment">// 数字到字符串</span><br><br><span class="hljs-comment">// 字符串类型的10进制数</span><br>strconv.Itoa(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">string</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">fmt: &#x27;b&#x27;/&#x27;e&#x27;/&#x27;f&#x27;/&#x27;g&#x27;</span><br><span class="hljs-comment">prec: 精度</span><br><span class="hljs-comment">bitSize: 32 for float32 / 64 for float64</span><br><span class="hljs-comment">*/</span><br>strconv.FormatFloat(f <span class="hljs-keyword">float64</span>, fmt <span class="hljs-keyword">byte</span>, prec, bitSize <span class="hljs-keyword">int</span>) <span class="hljs-keyword">string</span><br><br>----------------------------------------------------------------------------------------<br><span class="hljs-comment">// 字符串到数字</span><br><br><span class="hljs-comment">// string to int</span><br>strconv.Atoi(<span class="hljs-keyword">string</span>) (<span class="hljs-keyword">int</span>, error)<br><br><span class="hljs-comment">// string to float64</span><br>strconv.ParseFloat(s <span class="hljs-keyword">string</span>, bitSize <span class="hljs-keyword">int</span>) (<span class="hljs-keyword">float64</span>, error)<br></code></pre></td></tr></table></figure><h4 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h4><p><code>time</code>提供一个数据类型<code>time.Time</code>作为值使用，以及提供显示和测量时间和日期的功能函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">time.Now() Time <span class="hljs-comment">// 获得当前时间对象</span><br>time.Duration<span class="hljs-comment">// 两个时刻相差的纳秒数</span><br><span class="hljs-keyword">const</span> (<br>    Nanosecond  Duration = <span class="hljs-number">1</span><br>    Microsecond          = <span class="hljs-number">1000</span> * Nanosecond<br>    Millisecond          = <span class="hljs-number">1000</span> * Microsecond<br>    Second               = <span class="hljs-number">1000</span> * Millisecond<br>    Minute               = <span class="hljs-number">60</span> * Second<br>    Hour                 = <span class="hljs-number">60</span> * Minute<br>  )<br>time.Location<span class="hljs-comment">// 时区信息</span><br>time.Sleep(Duration) <span class="hljs-comment">//暂停</span><br>time.Since(t Time) Duration <span class="hljs-comment">// 当前时间到t的时间差</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Time)</span> <span class="hljs-title">Year</span>/<span class="hljs-title">Month</span>/<span class="hljs-title">Day</span><span class="hljs-params">()</span> <span class="hljs-title">int</span> // 相应年月日</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Time)</span> <span class="hljs-title">Format</span><span class="hljs-params">(layout <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span> // 根据格式，生产时间<span class="hljs-title">t</span>的格式化字符串</span><br></code></pre></td></tr></table></figure><h4 id="byte的相关操作"><a href="#byte的相关操作" class="headerlink" title="[]byte的相关操作"></a>[]byte的相关操作</h4><p><code>bytes</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// bytes.Buffer的声明和初始化</span><br><span class="hljs-keyword">var</span> buffer bytes.Buffer<br>buffer := &amp;bytes.Buffer&#123;&#125;<br>bytes.NewBuffer([]<span class="hljs-keyword">byte</span>) *Buffer<br>bytes.NewBufferString(<span class="hljs-keyword">string</span>) *Buffer<br><br><span class="hljs-comment">// 扩容公式 2*cap + dataLength</span><br><br><span class="hljs-comment">// 追加字符串(这种实现方式比使用 += 要更节省内存和 CPU，尤其是要串联的字符串数目特别多的时候)</span><br>Buffer#WriteString(<span class="hljs-keyword">string</span>) (<span class="hljs-keyword">int</span>, error)<br><br><span class="hljs-comment">// 转成字符串</span><br>Buffer#String() <span class="hljs-keyword">string</span><br></code></pre></td></tr></table></figure><h4 id="切片和数组的排序和搜索"><a href="#切片和数组的排序和搜索" class="headerlink" title="切片和数组的排序和搜索"></a>切片和数组的排序和搜索</h4><p><code>sort</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">sort.Ints(a []<span class="hljs-keyword">int</span>)<br>sort.IntsAreSorted(a []<span class="hljs-keyword">int</span>) <span class="hljs-keyword">bool</span><br>sort.SearchInts([]<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>) (index <span class="hljs-keyword">int</span>)  <span class="hljs-comment">// 采用的二分搜索，搜索前必须排序</span><br><span class="hljs-comment">// Float6s</span><br><span class="hljs-comment">// Strings</span><br></code></pre></td></tr></table></figure><h4 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h4><p><code>regexp</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">regexp.Compile(expr <span class="hljs-keyword">string</span>) (*Regexp, error)<br><br>regexp.Match(pattern <span class="hljs-keyword">string</span>, b []<span class="hljs-keyword">byte</span>) (matched <span class="hljs-keyword">bool</span>, err error)<br>(MatchReader/MatchString)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(re *Regexp)</span> <span class="hljs-title">ReplaceAllString</span><span class="hljs-params">(src, repl <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span><br></code></pre></td></tr></table></figure><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">Lock</span>/<span class="hljs-title">Unlock</span><span class="hljs-params">()</span></span><br><span class="hljs-comment">// RWMutex</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span> <span class="hljs-title">Do</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span>) // 确保函数只被调用一次</span><br><br><span class="hljs-comment">// 实现对象锁</span><br><span class="hljs-keyword">type</span> Info <span class="hljs-keyword">struct</span> &#123;<br>  mu sync.Mutex<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="精密计算"><a href="#精密计算" class="headerlink" title="精密计算"></a>精密计算</h4><p><code>math/big</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewInt</span><span class="hljs-params">(x <span class="hljs-keyword">int64</span>)</span> *<span class="hljs-title">Int</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(z *Int)</span> <span class="hljs-title">Add</span><span class="hljs-params">(x, y *Int)</span> *<span class="hljs-title">Int</span></span><br></code></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>定义 <code>const identifier [type] = value</code></p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol><li><p>只能存储布尔型、数字型、字符串的数据</p></li><li><p>未指定类型的常量，其类型由上下文决定</p></li><li><p>常量的值必须在编译时确定</p><blockquote><p>因为在编译时自定义函数属于未知，故不能赋值给常量，但内置函数可以，例如<code>len</code></p></blockquote></li><li><p>给常量赋值时，会导致编译错误</p></li><li><p>常量给变量赋值，超出变量范围时，会导致编译错误（不是运行错误）</p></li></ol><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><code>iota</code>用作枚举值，每遇到一个<code>const</code>就重置为0，每一行加一</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 赋值一个常量时，之后没赋值的常量都会应用上一行的赋值表达式</span><br><span class="hljs-keyword">const</span> (<br>a = <span class="hljs-literal">iota</span>  <span class="hljs-comment">// a = 0</span><br>b         <span class="hljs-comment">// b = 1</span><br>c         <span class="hljs-comment">// c = 2</span><br>d = <span class="hljs-number">5</span>     <span class="hljs-comment">// d = 5   </span><br>e         <span class="hljs-comment">// e = 5</span><br>)<br><br><span class="hljs-comment">// 赋值两个常量，iota 只会增长一次，而不会因为使用了两次就增长两次</span><br><span class="hljs-keyword">const</span> (<br>Apple, Banana = <span class="hljs-literal">iota</span> + <span class="hljs-number">1</span>, <span class="hljs-literal">iota</span> + <span class="hljs-number">2</span> <span class="hljs-comment">// Apple=1 Banana=2</span><br>Cherimoya, Durian                  <span class="hljs-comment">// Cherimoya=2 Durian=3</span><br>Elderberry, Fig                    <span class="hljs-comment">// Elderberry=3, Fig=4</span><br><br>)<br><br><span class="hljs-comment">// 使用 iota 结合 位运算 表示资源状态的使用案例</span><br><span class="hljs-keyword">const</span> (<br>Open = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span>  <span class="hljs-comment">// 0001</span><br>Close             <span class="hljs-comment">// 0010</span><br>Pending           <span class="hljs-comment">// 0100</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>_           = <span class="hljs-literal">iota</span>             <span class="hljs-comment">// 使用 _ 忽略不需要的 iota</span><br>KB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)          <span class="hljs-comment">// 1 &lt;&lt; (10*1)</span><br>MB                             <span class="hljs-comment">// 1 &lt;&lt; (10*2)</span><br>GB                             <span class="hljs-comment">// 1 &lt;&lt; (10*3)</span><br>TB                             <span class="hljs-comment">// 1 &lt;&lt; (10*4)</span><br>PB                             <span class="hljs-comment">// 1 &lt;&lt; (10*5)</span><br>EB                             <span class="hljs-comment">// 1 &lt;&lt; (10*6)</span><br>ZB                             <span class="hljs-comment">// 1 &lt;&lt; (10*7)</span><br>YB                             <span class="hljs-comment">// 1 &lt;&lt; (10*8)</span><br>)<br></code></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>声明 <code>var identifier type</code></p><p>初始化 <code>var indetifier [type] = value</code></p><blockquote><p>变量除了可以在全局声明中初始化，还可以在<code>init</code>函数中初始化。</p><p>初始化以单线程执行，并按包的依赖关系顺序执行</p></blockquote><p>局部变量的简短声明 <code>identifier := value</code></p><blockquote><p>同一变量不能二次简短声明</p></blockquote><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ol><li><p>一个变量声明后，系统会自动赋予该类型的零值</p></li><li><p>内部同名变量会隐藏外部变量</p></li></ol><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>变量（常量）包含的数据的数据类型，数据类型定义了变量值的范围和可对变量进行的操作</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="根据结构划分"><a href="#根据结构划分" class="headerlink" title="根据结构划分"></a>根据结构划分</h4><blockquote><p>格式：类型(零值)</p></blockquote><p><strong>基本类型</strong>：<code>int(0)</code> <code>float(0.0)</code>  <code>bool(false)</code> <code>string(&quot;&quot;)</code></p><p><strong>结构化的（复合的）</strong>：<code>struct</code> <code>array</code> <code>slice</code> <code>map</code> <code>channel</code> <code>pointer</code></p><blockquote><p>复合类型零值都为nil</p></blockquote><p><strong>描述行为的</strong>： <code>interface</code> <code>function</code></p><blockquote><p>nil</p></blockquote><h4 id="根据变量存储的信息的划分"><a href="#根据变量存储的信息的划分" class="headerlink" title="根据变量存储的信息的划分"></a>根据变量存储的信息的划分</h4><p><strong>值类型</strong>：<code>int</code> <code>float</code> <code>bool</code> <code>string</code> <code>arary</code> <code>struct</code></p><ol><li>变量指向内存中的值</li><li>赋值时拷贝值</li><li>值存储在栈中</li></ol><p><img src="/img/value_type.jpg" alt="值类型"><img src="/img/assigment_value_type.jpg" alt="值类型赋值"></p><p><strong>引用类型</strong>：<code>pointer</code>  <code>slice</code> <code>array</code> <code>channel</code></p><ol><li>变量指向值所在的内存地址，或内存地址的第一个字所在的位置</li><li>赋值时拷贝地址</li><li>值存储在堆中</li></ol><p><img src="/img/ref.jpg" alt="引用类型及赋值"></p><h3 id="类型相关操作"><a href="#类型相关操作" class="headerlink" title="类型相关操作"></a>类型相关操作</h3><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><code>a = T(b)</code> <strong>不同类型之间需要显示转换</strong></p><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>声明变量（常量）时不指定类型，类型由右值推导</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> i = <span class="hljs-number">1</span><span class="hljs-comment">//int</span><br>i := <span class="hljs-number">42</span>           <span class="hljs-comment">// int</span><br>f := <span class="hljs-number">3.142</span>        <span class="hljs-comment">// float64</span><br>g := <span class="hljs-number">0.867</span> + <span class="hljs-number">0.5i</span> <span class="hljs-comment">// complex128</span><br></code></pre></td></tr></table></figure><h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><p><code>type typeName typeLiteral</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ages <span class="hljs-keyword">int</span><br><br><span class="hljs-keyword">type</span> money <span class="hljs-keyword">float32</span><br><br><span class="hljs-keyword">type</span> months <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span><br><br>m := months &#123;<br><span class="hljs-string">&quot;January&quot;</span>:<span class="hljs-number">31</span>,<br><span class="hljs-string">&quot;February&quot;</span>:<span class="hljs-number">28</span>,<br>...<br><span class="hljs-string">&quot;December&quot;</span>:<span class="hljs-number">31</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><p><code>bool(true/false)</code> </p><blockquote><p>格式化化输出时，%t表示输出的值为布尔型</p><p>命名最好is/Is开头</p></blockquote><h4 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h4><h5 id="整型和浮点型"><a href="#整型和浮点型" class="headerlink" title="整型和浮点型"></a>整型和浮点型</h5><p><em>基于架构的</em>: <code>int</code> <code>unit</code> <code>uintptr</code></p><blockquote><p><code>int</code> <code>unit</code>在32位操作系统就32位，64位操作系统就64位</p><p><code>unitptr</code> 表示存放一个指针的长度</p></blockquote><p><em>架构独立的</em>：</p><ul><li>整数：<code>int8</code> <code>int16</code> <code>int32</code> <code>int64</code></li><li>无符号整数：<code>uint8</code> <code>unit16</code> <code>unit32</code> <code>unit64</code></li><li>浮点数：<code>float32</code> <code>float64</code>(推荐使用，<code>math</code>包中大量使用)</li></ul><p><em>进制及科学记数法</em>：<code>0八进制</code> <code>0x十六进制</code> <code>1e3==1000</code></p><p><em>格式化说明符</em>：</p><ul><li><p><code>%d</code> 格式化整数</p></li><li><p><code>%x</code> <code>%X</code> 格式化16进制数</p></li><li><p><code>%g</code> 格式化浮点数</p><blockquote><p><code>%f</code> <code>%e</code>的结合体</p></blockquote></li><li><p><code>%[0]nd</code> 指定长度和填充符</p></li><li><p><code>%n.m[g/e/f]</code> n位有效数字，m位小数 </p></li></ul><p><em>数字值转换</em>：</p><ol><li>未超出范围，截断</li><li>超出范围，<code>panic</code></li></ol><p><em>补充</em>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">byte</span> <span class="hljs-comment">// uint8 的别名  可表示ASCII字符</span><br><span class="hljs-keyword">rune</span> <span class="hljs-comment">// int32 的别名</span><br>    <span class="hljs-comment">// 表示一个 Unicode 码点</span><br></code></pre></td></tr></table></figure><h5 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h5><p><code>complex64 (32位实数，32位虚数)</code></p><p><code>complex128 (64, 64)</code>(推荐，<code>cmath</code>中大量使用)</p><p><em>字面值</em>：<code>实部+虚部i</code></p><p>数值转换：</p><ul><li><code>complex(r, i FloatType) ComplexType</code>(float32/float64)</li><li><code>real/imag(ComplexType) FloatType</code></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><em>定义</em>：字符是UTF-8字符的一个序列</p><p><em>字面值</em>：</p><ul><li>解释字符串：<code>&quot;&quot;</code> 其中转以字符会被替换<ul><li><code>\n</code> 换行</li><li><code>\r</code> 回车</li><li><code>\t</code> tab键</li><li><code>\u</code> 或 <code>\U</code> Unicode字符</li><li><code>\\</code> 反斜杆</li></ul></li><li>非解释字符串：<code>``</code></li></ul><p><em>特点</em>：值不可变</p><p><em>操作</em>：</p><ul><li><p>按字节中比较<code>== != &lt;= &gt;= &lt; &gt;</code></p></li><li><p><code>len(str)</code> 获得长度</p></li><li><p><code>[index]</code>索引取值</p><blockquote><p>仅适用于ASCII字符串</p></blockquote></li><li><p><code>+</code>拼接</p><blockquote><p><code>strings.Join</code> -&gt; <code>bytes.Buffer</code> 高效拼接</p></blockquote></li><li><p>子串<code>S[start:end]</code></p></li><li><p>展开<code>S...</code></p></li><li><p>通用迭代<code>for ix, value := range S &#123;&#125;</code></p></li></ul><p><em>注意事项</em>：获取字符串中某一字节的地址是非法的，例如<code>&amp;str[i]</code></p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><em>定义</em>：每个字有一个地址（16进制），该地址的数据类型即指针</p><p><em>特点</em>：<strong>一个指针变量可以指向任何值的内存地址</strong></p><blockquote><p>内存地址与值的大小无关，仅与机器字有关</p></blockquote><p><em>语法</em>： <code>*T</code></p><p><em>操作</em>：</p><ul><li><code>&amp;变量</code> 取变量的内存地址</li><li><code>*指针</code> 取指针指向的值</li><li><code>%p</code> 格式化指针</li></ul><p><em>注意点</em>：</p><ol><li>不能取字面量，常量的内存地址</li><li>反引用空指针会运行错误</li></ol><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><blockquote><p>Go提供以下条件结构和分支结构：</p><p><code>if-else</code>结构， <code>switch</code>结构， <code>select</code>结构</p><p>循环结构：</p><p><code>for(range)</code>结构</p></blockquote><h3 id="if-else结构"><a href="#if-else结构" class="headerlink" title="if-else结构"></a>if-else结构</h3><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> [initialization;] condition &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p>初始化语句中的变量作用于整个结构</p><blockquote><p><code>if</code> <code>else if</code> <code>else</code>中</p></blockquote><h3 id="switch结构"><a href="#switch结构" class="headerlink" title="switch结构"></a>switch结构</h3><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> [initialization;] 变量 &#123;<br><span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>[, 值<span class="hljs-number">2</span>]:<br>  ...<br><span class="hljs-keyword">case</span> 值<span class="hljs-number">3</span>:<br>  ...<br><span class="hljs-keyword">default</span>:<br>  ...<br>&#125;<br><br><span class="hljs-keyword">switch</span> [initialization;] &#123;<br><span class="hljs-keyword">case</span> 条件<span class="hljs-number">1</span>:<br>  ...<br><span class="hljs-keyword">case</span> 条件<span class="hljs-number">2</span>:<br>  ...<br><span class="hljs-keyword">default</span>:<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ol><li>自上而下匹配</li><li><code>case</code>自动<code>break</code>，除非<code>fallthrough</code></li></ol><h3 id="for结构"><a href="#for结构" class="headerlink" title="for结构"></a>for结构</h3><p><code>for 初始化语句; 条件表达式; 后置语句 &#123;&#125;</code> </p><p><code>for 条件表达式 &#123;&#125;</code> </p><p><code>for &#123;&#125;</code> 无限循环</p><p><code>for ix, val := range coll &#123;&#125;</code> 迭代集合</p><blockquote><p><code>val</code>为元素的值拷贝</p><p><code>for-range</code>会按UTF-8规则识别Unicode编码的字符</p><p>口诀：省2空1</p></blockquote><h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><p><code>break</code>结束循环</p><p><code>continue</code>跳过当前迭代</p><blockquote><p>关键字 continue 只能被用于 for 循环中</p></blockquote><h3 id="标签和goto"><a href="#标签和goto" class="headerlink" title="标签和goto"></a>标签和goto</h3><p>标签配合<code>for</code> <code>switch</code> <code>select</code></p><blockquote><p>标签名大小写敏感</p></blockquote><p><code>goto/break/continue 标签名</code></p><blockquote><p>goto只能在函数内跳转</p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote><p><code>&#125;</code> 或 <code>return语句</code>意味着函数的退出</p><p>Go有三种类型的函数:</p><ol><li><p>具名函数</p></li><li><p>匿名函数</p></li><li><p>方法</p></li></ol><p>除了main()、init()函数外，其它所有类型的函数都可以有参数与返回值</p><p>函数参数、返回值以及它们的类型被统称为函数签名</p></blockquote><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcName</span><span class="hljs-params">(parameterList)</span> <span class="hljs-params">(returnValueList)</span></span> &#123;<br>  ...<br>&#125;<br><br>parameterList: (p1 type1, p2 type2, ...)<br>returnValueList: (r1 type1, r2 type2, ...)<br></code></pre></td></tr></table></figure><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><ol><li><p>不能重载</p></li><li><p>具名函数的声明不能嵌套</p></li><li><p>函数签名可做类型<code>type &lt;type name&gt; func (...) (...)</code>（函数可作为参数传递）</p><blockquote><p>回调：函数作为参数，在其他函数内调用</p><p>高阶函数：返回其他函数的函数 和 接收其他函数作为参数的函数</p></blockquote></li><li><p>函数是一等值，可赋值和比较</p></li></ol><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><ol><li>接受无参、单参、多参</li><li>变参<code>...T</code> (本质是<code>slice</code>)</li></ol><h4 id="按值传递和按引用传递"><a href="#按值传递和按引用传递" class="headerlink" title="按值传递和按引用传递"></a>按值传递和按引用传递</h4><ol><li>Go 默认使用按值传递，也就是传递参数的副本</li><li>像切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递（即使没有显式的指出指针）</li></ol><blockquote><p>传递参数的值即按值传递</p><p>传递参数的地址即按引用传递</p></blockquote><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ol><li><p>可多值返回（eg: 减少指针传入）</p><blockquote><p>任何一个有返回值(1个、多个)的函数都必须以<code>return</code> <code>panic</code>结尾</p></blockquote></li><li><p>命名返回值</p><blockquote><p>命名返回值作为结果形参（result parameters）被初始化为相应类型的零值</p><p>空<code>return</code>返回</p></blockquote></li></ol><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><ol><li><p>将函数调用推迟到外层函数<code>return</code>后执行</p></li><li><p>参数会立即求值</p></li><li><p>defer栈</p></li></ol><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>函数体内调用自身</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>匿名函数又称为闭包：它们允许调用在其他环境下的变量。</p><h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><p>保存并积累外部函数的局部变量，不管外部函数退出与否，都能够操作这些变量。</p><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>close</td><td>用于管道通信</td></tr><tr><td>len、cap</td><td>len获得长度或数量(<code>string</code> <code>array</code> <code>slice</code> <code>map</code> <code>channel</code>)，cap获得容量(<code>slice</code> <code>map</code>)</td></tr><tr><td>new、make</td><td>用于分配内存，new返回指针，make(T, args)返回T类型的非零值（<code>slice</code> <code>map</code> <code>channel</code>）</td></tr><tr><td>copy、append</td><td>复制和连接切片</td></tr><tr><td>panic、recover</td><td>用于错误处理机制</td></tr><tr><td>print、println</td><td>底层打印函数，输出到标准错误流</td></tr><tr><td>complex、real、imag</td><td>用于创建和操作复数</td></tr></tbody></table><h3 id="main和init函数"><a href="#main和init函数" class="headerlink" title="main和init函数"></a>main和init函数</h3><p>相同点：</p><ol><li>无参无返回值</li><li>Go会自动调用</li></ol><p>不同点：</p><ol><li><code>main</code>只能作用于<code>main</code>包, <code>init</code>可作用于所有包</li><li><code>main</code>包必须有一个<code>main</code>，包中可有任意个<code>init</code>(推荐一个)</li></ol><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><blockquote><p><code>[]</code>进行操作</p></blockquote><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>同类型元素的定长有序序列</p><h4 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h4><p>声明格式：<code>var id [len]type</code></p><p>初始化:</p><ol><li><code>id := [len]type&#123;v1, ...&#125;</code></li><li><code>id := [...]type&#123;v1, ...&#125;</code></li><li><code>id := [len]type&#123;ix1: v1, ...&#125;</code></li><li><code>id := new([len]type)</code></li></ol><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol><li><p>长度必须是常量表达式，且为非负整数</p></li><li><p>数组长度也是数组类型的一部分</p><blockquote><p><code>[5]int</code>和<code>[10]int</code>是不同类型</p></blockquote></li><li><p>最大长度是2GB</p></li><li><p>索引范围[0, len -1]</p><blockquote><p>索引越界: <code>runtime error: index out of range</code></p></blockquote></li><li><p>声明后元素会赋为类型的零值</p></li><li><p>数组是<strong>值类型</strong></p></li><li><p>相同类型的数组支持相等性比较 <code>==</code> <code>!=</code></p></li></ol><h4 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h4><p><img src="/img/array_in_memory.png" alt="数组内存结构"></p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ol><li>通过<code>[索引]</code>读取、修改元素的值</li><li>迭代<ul><li><code>for i := 0; i &lt; len(A); &#123;&#125;</code></li><li><code>for ix, value := range A &#123;&#125;</code></li></ul></li><li>数组作为参数的最佳实践<ul><li>传指针 <code>func Change(A *[5]int) &#123;&#125;</code></li><li>传切片 <code>func Chaneg(A []int) &#123;&#125;</code></li></ul></li></ol><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p><code>[len1][len2]...type</code></p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>数组片段的引用</p><blockquote><p>该数组称之为相关数组，通常是匿名的</p><p>这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集</p></blockquote><h4 id="声明和初始化-1"><a href="#声明和初始化-1" class="headerlink" title="声明和初始化"></a>声明和初始化</h4><p>声明：<code>var id []type</code></p><p>初始化：</p><ul><li><p><code>id := A[start:end]</code></p><blockquote><p>A for array</p></blockquote></li><li><p><code>id := []type&#123;v1, ...&#125;</code></p></li><li><p><code>id := S[start:end]</code></p><blockquote><p>S for Slice，仍然引用相关数组</p></blockquote></li><li><p><code>id := make([]type, len[, cap])</code>创建一个切片和相关数组</p><blockquote><p>cap省略时，len(s) == cap(s) == len</p></blockquote><p>  <img src="/img/makeslice.png" alt="make切片的内存结构"></p></li></ul><h4 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h4><ol><li><p>可索引且长度可变</p></li><li><p><code>0 &lt;= len(s) &lt;= cap(s) &lt;= len(相关数组)</code></p></li><li><p>切片是<strong>引用类型</strong></p><blockquote><p>多个切片如果表示同一个数组的片段，它们可以共享数据</p><p>不用要指针指向切片</p></blockquote></li><li><p>切片不能直接比较</p><blockquote><p> 不能使用<code>==</code> <code>!=</code>操作符来判断两个切片是否含有全部相等元素</p></blockquote></li></ol><h4 id="内存结构-1"><a href="#内存结构-1" class="headerlink" title="内存结构"></a>内存结构</h4><p>三个域的结构体：指向相关数组的指针，切片长度，切片容量</p><p>下图给出了一个长度为 2，容量为 4 的切片y：</p><ul><li><code>y[0] = 3</code> 且 <code>y[1] = 5</code>。</li><li>切片 <code>y[0:4]</code> 由 元素 3，5，7 和 11 组成。</li></ul><p><img src="/img/slice_in_memory.png" alt="切片的内存结构"></p><h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><ol><li><p>通过<code>[索引]</code>读取、修改元素的值</p></li><li><p>长度 <code>len(S)</code>元素个数</p></li><li><p>容量 <code>cap(S)</code>切片第一元素到相关数组末尾的长度</p></li><li><p>迭代 <code>for ix, value := range S &#123;&#125;</code></p></li><li><p>切片重组 <code>S = S[start:end]</code></p><blockquote><p>即改变切片长度的过程</p></blockquote></li><li><p>复制 <code>func copy(dst []Type, src []Type) int</code>复制的个数</p></li><li><p>追加 <code>func append(slice []Type, elems ...Type) []Type</code></p></li><li><p>展开 <code>S...</code></p></li></ol><h4 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h4><p><code>[][]...type</code></p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>一种元素对（pair）的无序集合</p><blockquote><p>快速寻找值的理想结构</p></blockquote><h4 id="声明和初始化-2"><a href="#声明和初始化-2" class="headerlink" title="声明和初始化"></a>声明和初始化</h4><p>声明：<code>var id map[keytype]valuetype</code></p><p>初始化：</p><ul><li><code>id := map[keytype]valuetype&#123;key: value, ...&#125; </code></li><li><code>id := make(map[keytype]valuetype, capacity)</code></li></ul><h4 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h4><ol><li><p>长度动态增长</p></li><li><p>引用类型</p></li><li><p>不支持直接比较</p></li><li><p>key只能是支持<code>==</code> <code>!=</code>的类型</p><blockquote><p><code>int</code> <code>float</code> <code>string</code> … <code>pointer</code> <code>interface</code> <code>array</code> <code>channel</code></p><p><code>slice</code> , <code>map</code>, 包含不可比较的<code>struct</code> , <code>function</code>不能作为key</p><p>如果要用结构体作为key，可以提供<code>Key()</code> 和<code>Hash()</code>方法</p></blockquote></li><li><p>线程不安全</p></li></ol><h4 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h4><ol><li><p><code>M[key]</code>用来读取值</p><blockquote><p>key不存在，会返回valuetype的零值</p></blockquote></li><li><p><code>M[key] = value</code>用来修改值和添加键值对</p></li><li><p><code>len(M)</code>元素对个数</p></li><li><p>检测键值对是否存在<code>value, ok := M[key]</code></p></li><li><p>删除键值对<code>delete(M, key)</code></p><blockquote><p>key不存在不会引发错误</p></blockquote></li><li><p>迭代<code>for key, value := range M &#123;&#125;</code></p></li><li><p>排序<code>将key存入切片，再排序切片</code></p><blockquote><p>元素对的有序集合，用结构体切片更好</p></blockquote></li></ol><h4 id="Map的切片"><a href="#Map的切片" class="headerlink" title="Map的切片"></a>Map的切片</h4><p><code>[]map[keytype][valuetype]</code></p><blockquote><p>双<code>make</code></p><p>第一个为切片分配内存</p><p>第二个为切片中的每个<code>map</code>分配内存</p></blockquote><h3 id="make和new"><a href="#make和new" class="headerlink" title="make和new"></a>make和new</h3><blockquote><p><strong>口诀</strong>：<code>new</code>分配内存，<code>make</code>初始化</p></blockquote><p><code>make</code>用于内建类型（<code>map</code>、<code>slice</code> 和<code>channel</code>）的内存分配</p><blockquote><p><code>make</code>返回初始化后的值</p><p>导致这三个类型有所不同的原因：</p><p>是指向数据结构的引用在使用前必须被初始化</p></blockquote><p><code>new</code>用于各种类型的内存分配</p><blockquote><p><code>new</code>返回 指向类型<code>T</code>零值的指针</p></blockquote><p><img src="/img/makenew.png" alt="make和new的区别"></p><h3 id="字符串、数组、切片的应用"><a href="#字符串、数组、切片的应用" class="headerlink" title="字符串、数组、切片的应用"></a>字符串、数组、切片的应用</h3><h4 id="从字符串生成字节切片"><a href="#从字符串生成字节切片" class="headerlink" title="从字符串生成字节切片"></a>从字符串生成字节切片</h4><p><code>chs := []byte(s)</code></p><p><code>copy(dst []byte, src string)</code></p><h4 id="字符串和切片的内存结构"><a href="#字符串和切片的内存结构" class="headerlink" title="字符串和切片的内存结构"></a>字符串和切片的内存结构</h4><p>在内存中，一个字符串是一个双字结构，即一个指向实际数据的指针和记录字符串长度的整数</p><p><img src="/img/string_in_memory.png" alt="字符串和切片的"></p><h4 id="修改字符串中的字符"><a href="#修改字符串中的字符" class="headerlink" title="修改字符串中的字符"></a>修改字符串中的字符</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;hello&quot;</span><br>c := []<span class="hljs-keyword">byte</span>(s)<br>c[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;c&#x27;</span><br>s2 := <span class="hljs-keyword">string</span>(c) <span class="hljs-comment">// s2 == &quot;cello&quot;</span><br></code></pre></td></tr></table></figure><h4 id="字节数组对比函数"><a href="#字节数组对比函数" class="headerlink" title="字节数组对比函数"></a>字节数组对比函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Compare</span><span class="hljs-params">(a, b[]<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(a) &amp;&amp; i &lt; <span class="hljs-built_in">len</span>(b); i++ &#123;<br>        <span class="hljs-keyword">switch</span> &#123;<br>        <span class="hljs-keyword">case</span> a[i] &lt; b[i]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        <span class="hljs-keyword">case</span> a[i] &gt; b[i]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 数组的长度可能不同</span><br>    <span class="hljs-keyword">switch</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">len</span>(a) &lt; <span class="hljs-built_in">len</span>(b):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">len</span>(a) &gt; <span class="hljs-built_in">len</span>(b):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 数组相等</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="append常见操作"><a href="#append常见操作" class="headerlink" title="append常见操作"></a>append常见操作</h4><ol><li>将切片<code>b</code>的元素追加到切片<code>a</code>后：<code>a = append(a, b...)</code></li><li>切片增加<code>j</code>个长度：<code>a = append(a, make([]T, j)...)</code></li><li>在索引<code>i</code>增长<code>j</code>个长度：<code>a = append(a[:i], append(make([]T, j), a[i:]...)...)</code></li><li>删除切片索引<code>i</code>的元素：<code>a = append(a[:i], a[i+1:]...)</code></li><li>删除切片索引<code>[i, j)</code>的元素：<code>a = append(a[:i], a[j:]...)</code></li><li>弹出切片尾部元素：<code>x, a = a[len(a)-1], a[:len(a)-1]</code></li><li>在索引<code>i</code>插入元素<code>x</code>：<code>a = append(a[:i], append([]T&#123;x&#125;, a[i:]...)...)</code></li><li>在索引<code>i</code>插入切片<code>b</code>的所有元素：<code>a = append(a[:i], append(b, a[i:]...)...)</code></li></ol><h4 id="切片和垃圾回收"><a href="#切片和垃圾回收" class="headerlink" title="切片和垃圾回收"></a>切片和垃圾回收</h4><p>只有没有切片指向相关数组时，内存才会被释放，这种特性有时会造成内存浪费</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> digitRegexp = regexp.MustCompile(<span class="hljs-string">`\d+`</span>)<br><br><span class="hljs-comment">// 返回的字节切片引用了整个文件（即占用了整个文件的内存）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindDigits</span><span class="hljs-params">(filename <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">byte</span></span> &#123;<br>file, _ := ioutil.ReadFile(filename)<br><span class="hljs-keyword">return</span> digitRegexp.Find(file)<br>&#125;<br><br><span class="hljs-comment">// 仅占用有效数字的内存</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LowFindDigits</span><span class="hljs-params">(filename <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">byte</span></span> &#123;<br>file, _ := ioutil.ReadFile(filename)<br>digits := digitRegexp.Find(file)<br>cache := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-built_in">len</span>(digits))<br><span class="hljs-built_in">copy</span>(cache, digits)<br><span class="hljs-keyword">return</span> cache<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结构与方法"><a href="#结构与方法" class="headerlink" title="结构与方法"></a>结构与方法</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><h4 id="定义、声明、初始化"><a href="#定义、声明、初始化" class="headerlink" title="定义、声明、初始化"></a>定义、声明、初始化</h4><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>  field fieldtype [tag] <span class="hljs-comment">// tag是字符串</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>声明：<code>var id T</code></p><p>初始化：</p><ul><li><code>id := T&#123;value, ...&#125;</code></li><li><code>id := T&#123;field: value, ...&#125;</code></li><li><code>id := new(T)</code>等价于<code>id := &amp;T&#123;&#125;</code></li></ul><p><img src="/img/newStruct.jpg" alt="new初始化"></p><p><img src="/img/structLiteral.jpg" alt="字面量初始化"></p><h4 id="注意点-3"><a href="#注意点-3" class="headerlink" title="注意点"></a>注意点</h4><ol><li><p>结构体是值类型</p></li><li><p><strong>基于字段</strong>判断是否能进行相等性比较</p></li><li><p>每一个类型只能有一个匿名字段，匿名字段名即类型名</p></li><li><p>匿名字段可能导致命名冲突</p><blockquote><ol><li>外层名字会覆盖内层名字，但内存空间保留</li><li>相同名字在同一级别出现两次，如果该名字被使用，则会引发错误（不使用该名字，不会引发错误）</li></ol></blockquote></li></ol><h4 id="内存结构-2"><a href="#内存结构-2" class="headerlink" title="内存结构"></a>内存结构</h4><p>结构体和它的字段在内存中连续分配</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Rect1 <span class="hljs-keyword">struct</span> &#123;Min, Max Point &#125;<br><span class="hljs-keyword">type</span> Rect2 <span class="hljs-keyword">struct</span> &#123;Min, Max *Point &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/struct_in_memory.jpg" alt="结构体和其字段的内存分布"></p><h4 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h4><ol><li>选择器<code>.</code><ul><li>访问自身字段和匿名字段的字段，对结构体指针自动反引用</li><li>调用自身方法和匿名字段的方法，对指针接受者自动重定向</li></ul></li><li><code>reflect</code>包获得标签<code>tag</code></li></ol><h4 id="递归结构体"><a href="#递归结构体" class="headerlink" title="递归结构体"></a>递归结构体</h4><p>结构体的字段的类型可以是自己</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 双链表</span><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>  prev *Node<br>  data <span class="hljs-keyword">float64</span><br>  next *Node<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>带 <strong>接收者</strong> 的函数</p><blockquote><p>类型 T（或 *T）上的所有方法的集合叫做类型 T（或 *T）的方法集（method set）</p></blockquote><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p><code>func (recv T) methodName(paramterList) returnValueList &#123;&#125;</code></p><h4 id="注意点-4"><a href="#注意点-4" class="headerlink" title="注意点"></a>注意点</h4><ol><li><p>类型和其方法必须在同一个包里定义</p></li><li><p>接受者类型不能是内建类型和接口，但可以是内建类型的别名类型</p></li><li><p>不允许方法重载</p><blockquote><p>一个类型<code>T&amp;*T</code>只能由一个给定名称的方法</p></blockquote></li></ol><h4 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a>操作</h4><p>选择器<code>.</code>调用方法，且对指针接受者自动重定向</p><h4 id="接受者与接口"><a href="#接受者与接口" class="headerlink" title="接受者与接口"></a>接受者与接口</h4><p><strong>调用</strong></p><p>值接受者方法，可以通过值调用，也可以通过指针调用</p><p>指针接受者方法，只能通过指针和可取地址的值调用</p><blockquote><p>补充: （值方法集：值接受者方法集，指针方法集：指针接受者方法集）</p><ul><li>一个类型可以有值方法集和指针方法集<ul><li>值方法集是指针方法集的真子集</li></ul></li><li>规则<ul><li>值对象只能使用值方法集</li><li>指针对象能使用 值方法集 + 指针方法集</li></ul></li><li>接口的匹配(或者叫实现)<ul><li>类型实现了接口的所有方法,叫匹配</li><li>具体的讲,要么类型的值方法集匹配接口,要么指针方法集匹配接口</li></ul></li></ul><p>具体的匹配分两种:</p><ul><li>值方法集和接口匹配<ul><li>给接口变量赋值的可以是值对象和指针对象,因为都包含值方法集</li></ul></li><li>指针方法集和接口匹配<ul><li>只能将指针对象赋值给接口变量,因为只有指针方法集和接口匹配</li><li>如果将值对象赋值给接口变量,会引发编译错误(会触发接口合理性检查机制)</li></ul></li></ul></blockquote><h2 id="接口与反射"><a href="#接口与反射" class="headerlink" title="接口与反射"></a>接口与反射</h2><h1 id="高级编程"><a href="#高级编程" class="headerlink" title="高级编程"></a>高级编程</h1><h2 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h2><h2 id="错误处理与测试"><a href="#错误处理与测试" class="headerlink" title="错误处理与测试"></a>错误处理与测试</h2><h3 id="panic和recover函数"><a href="#panic和recover函数" class="headerlink" title="panic和recover函数"></a>panic和recover函数</h3><p><code>panic</code>中断当前控制流程，进入<code>panic</code>状态</p><blockquote><p><code>F</code>调用<code>panic</code>，<code>F</code>中断执行，但<code>defer</code>函数正常执行，然后返回调用<code>F</code>的地方，接着<code>panic</code>会向上传递，直到发送<code>panic</code>的<code>goroutine</code>中所有调用的函数返回，此时程序退出。</p></blockquote><p><code>recover</code>恢复进入<code>panic</code>的<code>goroutine</code></p><blockquote><p><code>recover</code>仅在<code>defer</code>函数中有效</p><p>正常情况下<code>recover</code>返回<code>nil</code></p><p><code>recover</code>可以获得<code>panic</code>的输入值，并恢复正常执行</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> x := <span class="hljs-built_in">recover</span>(); x != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// recover and process</span><br>&#125;<br>&#125;()<br><br><span class="hljs-comment">// normal process</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="协程与通道"><a href="#协程与通道" class="headerlink" title="协程与通道"></a>协程与通道</h2><h2 id="网络、模版与网页应用"><a href="#网络、模版与网页应用" class="headerlink" title="网络、模版与网页应用"></a>网络、模版与网页应用</h2><h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><h2 id="常见陷阱与错误"><a href="#常见陷阱与错误" class="headerlink" title="常见陷阱与错误"></a>常见陷阱与错误</h2><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><h2 id="出于性能考虑的代码段"><a href="#出于性能考虑的代码段" class="headerlink" title="出于性能考虑的代码段"></a>出于性能考虑的代码段</h2><h2 id="构建一个完整应用"><a href="#构建一个完整应用" class="headerlink" title="构建一个完整应用"></a>构建一个完整应用</h2><h1 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h1><p>定义：</p><ol><li><p>接收者的类型定义和方法声明必须在同一包内</p></li><li><p>接收者不能为内建类型， 可通过<code>type</code>绕过</p></li><li><p>指针接收者直接操作对象内容（推荐）</p></li><li><p>指针重定向</p><blockquote><p>*T    V.method &lt;=&gt; (&amp;V).method</p><p>T     P.method &lt;=&gt; (*P).method</p></blockquote></li></ol><p><strong>继承</strong>：匿名字段</p><p><strong>重写</strong>：同名方法</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p><strong>接口</strong>：一组方法签名</p><p><strong>接口类型</strong>：定义了一组方法，如果某个对象实现了某个接口的所有方法，该对象就实现了该接口</p><p><strong>接口变量</strong>：接口变量可以存储任何实现该接口的对象</p><p><strong>接口参数</strong>：让函数接受实现该接口的对象</p><p><strong>空接口</strong><code>interface &#123;&#125;</code>：所有的类型都实现了空接口, 用于存储任意类型的值</p><p><strong>接口变量存储的类型</strong></p><ul><li><p>comma-ok断言</p><blockquote><p><code> value, ok = element.(T)</code>如果element存储了T类型的数值，那么ok为true，否则false</p></blockquote></li><li><p>switch测试</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> v := i.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> T:<br>    <span class="hljs-comment">// v 的类型为 T</span><br><span class="hljs-keyword">case</span> S:<br>    <span class="hljs-comment">// v 的类型为 S</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 没有匹配，v 与 i 的类型相同</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>嵌入接口</strong>: 隐式包含方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// io.ReadWriter</span><br><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;<br>Reader<br>Writer<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>常见接口</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// fmt.Stringer</span><br><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;<br>  String() <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// builtins</span><br><span class="hljs-comment">// 模拟错误</span><br><span class="hljs-keyword">type</span> error <span class="hljs-keyword">interface</span> &#123;<br>  Error() <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">// 错误处理工具包errors</span><br>err := errors.New(<span class="hljs-string">&quot;some error&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Print(err)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// io.Reader</span><br><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;<br>Read(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>检查程序运行时状态的能力</p><p><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/02.6.md">https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/02.6.md</a></p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p><strong>Go的runtime管理的一个线程管理器</strong></p><p><code>go fn(x)</code>会启动一个<code>goroutine</code>并执行<code>fn(x)</code></p><ol><li><code>fn</code> ,<code>x</code>的求值在当前<code>goroutine</code>，<code>fn</code>执行在新<code>goroutine</code></li><li>多个<code>goroutine</code>运行在同一个进程里面，共享内存数据</li></ol><h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><p><strong>带有类型的管道， 用于goroutine间的通信</strong></p><p>必须通过<code>make</code>创建: <code>ch := make(chan int)</code> </p><p><code>&lt;-</code>操作符</p><ul><li><code>ch &lt;- v</code> 发送值到信道</li><li><code>v := &lt;-ch</code> 从信道接受值</li></ul><p><strong>特点</strong>：</p><ol><li>无缓冲信道发送、接受操作会阻塞（使得Go在没有显示锁或竞态变量的情况下保证同步）</li><li>信道可以带缓冲（仅当缓冲器满，向其发送值才会阻塞，仅当缓冲区为空，从其接受值才会阻塞）</li></ol><p><strong>range和close</strong></p><p><code>for i := range c</code>能够不断的读取信道里面的数据，直到该信道被显式的关闭</p><p><code>v, ok := &lt;-ch</code>可测试信道是否关闭</p><p>生产者关闭信道， 而不是消费值</p><p>信道无需像文件一样经常关闭，只有当无数据可发，或显示结束range时才</p><p><strong>select</strong>: 监听多个信道的数据流动</p><ol><li>默认阻塞，直到有信道有数据流动</li><li>当多个信道有数据流动，则随机执行</li><li>当所有信道都没有数据流动，<code>default</code> 就执行</li></ol><p><strong>超时技巧</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>o := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> v := &lt;- c:<br><span class="hljs-built_in">println</span>(v)<br><span class="hljs-keyword">case</span> &lt;- time.After(<span class="hljs-number">5</span> * time.Second):<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;timeout&quot;</span>)<br>o &lt;- <span class="hljs-literal">true</span><br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;()<br>&lt;- o<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>runtime包处理goroutine的函数</strong></p><ul><li><p>Goexit</p><p>  退出当前执行的goroutine，但是defer函数还会继续调用</p></li><li><p>Gosched</p><p>  让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。</p></li><li><p>NumCPU</p><p>  返回 CPU 核数量</p></li><li><p>NumGoroutine</p><p>  返回正在执行和排队的任务总数</p></li><li><p>GOMAXPROCS</p><p>  用来设置可以并行计算的CPU核数的最大值，并返回之前的值。</p></li></ul><h2 id="互斥锁（sync-Mutex）"><a href="#互斥锁（sync-Mutex）" class="headerlink" title="互斥锁（sync.Mutex）"></a>互斥锁（sync.Mutex）</h2><p>方法</p><ul><li><code>Lock</code></li><li><code>Unlock</code> 用<code>defer</code>保证一定解锁</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-comment">// 异步爬虫</span><br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Fetcher <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Fetch 返回 URL 的 body 内容，并且将在这个页面上找到的 URL 放到一个 slice 中。</span><br>Fetch(url <span class="hljs-keyword">string</span>) (body <span class="hljs-keyword">string</span>, urls []<span class="hljs-keyword">string</span>, err error)<br>&#125;<br><br><span class="hljs-keyword">type</span> Record <span class="hljs-keyword">struct</span> &#123;<br>v     <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span><br>mutex sync.Mutex<br>group sync.WaitGroup<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Record)</span> <span class="hljs-title">repeat</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>r.mutex.Lock()<br><span class="hljs-keyword">defer</span> r.mutex.Unlock()<br><span class="hljs-keyword">if</span> _, in := r.v[url]; in &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>r.v[url] = <span class="hljs-literal">true</span><br>r.group.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">var</span> record = Record&#123;v: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span>)&#125;<br><br><span class="hljs-comment">// Crawl 使用 fetcher 从某个 URL 开始递归的爬取页面，直到达到最大深度。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Crawl</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>, depth <span class="hljs-keyword">int</span>, fetcher Fetcher)</span></span> &#123;<br><span class="hljs-keyword">defer</span> record.group.Done()<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 并行的抓取 URL。</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 不重复抓取页面。</span><br><span class="hljs-comment">// 下面并没有实现上面两种情况：</span><br><span class="hljs-keyword">if</span> depth &lt;= <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>body, urls, err := fetcher.Fetch(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;found: %s %q\n&quot;</span>, url, body)<br><span class="hljs-keyword">for</span> _, u := <span class="hljs-keyword">range</span> urls &#123;<br><span class="hljs-keyword">if</span> !record.repeat(u) &#123;<br><span class="hljs-keyword">go</span> Crawl(u, depth<span class="hljs-number">-1</span>, fetcher)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> url = <span class="hljs-string">&quot;https://golang.org/&quot;</span><br>record.repeat(url)<br>Crawl(url, <span class="hljs-number">4</span>, fetcher)<br>record.group.Wait()<br>&#125;<br><br><span class="hljs-comment">// fakeFetcher 是返回若干结果的 Fetcher。</span><br><span class="hljs-keyword">type</span> fakeFetcher <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*fakeResult<br><br><span class="hljs-keyword">type</span> fakeResult <span class="hljs-keyword">struct</span> &#123;<br>body <span class="hljs-keyword">string</span><br>urls []<span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f fakeFetcher)</span> <span class="hljs-title">Fetch</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, []<span class="hljs-keyword">string</span>, error)</span></span> &#123;<br><span class="hljs-keyword">if</span> res, ok := f[url]; ok &#123;<br><span class="hljs-keyword">return</span> res.body, res.urls, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;not found: %s&quot;</span>, url)<br>&#125;<br><br><span class="hljs-comment">// fetcher 是填充后的 fakeFetcher。</span><br><span class="hljs-keyword">var</span> fetcher = fakeFetcher&#123;<br><span class="hljs-string">&quot;https://golang.org/&quot;</span>: &amp;fakeResult&#123;<br><span class="hljs-string">&quot;The Go Programming Language&quot;</span>,<br>[]<span class="hljs-keyword">string</span>&#123;<br><span class="hljs-string">&quot;https://golang.org/pkg/&quot;</span>,<br><span class="hljs-string">&quot;https://golang.org/cmd/&quot;</span>,<br>&#125;,<br>&#125;,<br><span class="hljs-string">&quot;https://golang.org/pkg/&quot;</span>: &amp;fakeResult&#123;<br><span class="hljs-string">&quot;Packages&quot;</span>,<br>[]<span class="hljs-keyword">string</span>&#123;<br><span class="hljs-string">&quot;https://golang.org/&quot;</span>,<br><span class="hljs-string">&quot;https://golang.org/cmd/&quot;</span>,<br><span class="hljs-string">&quot;https://golang.org/pkg/fmt/&quot;</span>,<br><span class="hljs-string">&quot;https://golang.org/pkg/os/&quot;</span>,<br>&#125;,<br>&#125;,<br><span class="hljs-string">&quot;https://golang.org/pkg/fmt/&quot;</span>: &amp;fakeResult&#123;<br><span class="hljs-string">&quot;Package fmt&quot;</span>,<br>[]<span class="hljs-keyword">string</span>&#123;<br><span class="hljs-string">&quot;https://golang.org/&quot;</span>,<br><span class="hljs-string">&quot;https://golang.org/pkg/&quot;</span>,<br>&#125;,<br>&#125;,<br><span class="hljs-string">&quot;https://golang.org/pkg/os/&quot;</span>: &amp;fakeResult&#123;<br><span class="hljs-string">&quot;Package os&quot;</span>,<br>[]<span class="hljs-keyword">string</span>&#123;<br><span class="hljs-string">&quot;https://golang.org/&quot;</span>,<br><span class="hljs-string">&quot;https://golang.org/pkg/&quot;</span>,<br>&#125;,<br>&#125;,<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/02/13/hello-world/"/>
    <url>/2021/02/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
