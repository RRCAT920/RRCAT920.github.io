<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《The Way to Go》笔记</title>
    <link href="/2021/02/23/%E3%80%8AThe-Way-to-Go%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/02/23/%E3%80%8AThe-Way-to-Go%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Go起源、发展、普及"><a href="#Go起源、发展、普及" class="headerlink" title="Go起源、发展、普及"></a>Go起源、发展、普及</h1><p><img src="/img/gopher.png" alt="Go 语言设计者：Griesemer、Thompson 和 Pike"></p><p><img src="/img/otherlang.png" alt="其它编程语言对 Go 语言的影响"></p><p><strong>为什么创造Go?</strong></p><ol><li>缺少与时代相符合的系统级编程语言</li><li>要充分利用硬件</li><li>快速编译、高效执行、易于开发</li></ol><p><strong>Go的发展目标</strong></p><ol><li><p>将静态语言的安全性和高效性与动态语言的易开发性结合</p><blockquote><p>类型安全、内存安全，有指针，但不允许指针操作</p></blockquote></li><li><p>支持网络通信、并发并行编程，以更好的利用分布式和多核计算机</p><blockquote><p>goroutine、channel、分段栈增长、goroutine在线程基础上多路复用技术的自动化(select)</p><p>分段栈：栈空间初始大小很小，之后自动增长，从而保证开多个线程或协程而不耗尽内存</p></blockquote></li><li><p>构建速度（编译和链接到机器代码的速度）</p><blockquote><p>主要针对C++</p></blockquote></li><li><p>执行速度、垃圾回收、反射、调用C库</p></li></ol><p><strong>指导设计原则</strong></p><ol><li>减少关键字数量来简化编码的复杂度和混乱度</li><li>只提供一到两个方法解决问题，提高代码可读性</li><li>概念之间相互独立</li></ol><p><strong>语言特性</strong></p><ol><li>天然并发</li><li>没有类和继承的概念，通过接口实现多态</li><li>函数是基本构件</li><li>强静态类型</li><li>支持动态语言的一些特性</li><li>支持交叉编译</li></ol><p><strong>用途</strong></p><p>Web服务器、存储集群、游戏服务器、复杂事件处理(CEP)</p><blockquote><p>不合适实时性要求高的软件（垃圾回收、自动内存分配）</p></blockquote><h1 id="安装Go与运行环境"><a href="#安装Go与运行环境" class="headerlink" title="安装Go与运行环境"></a>安装Go与运行环境</h1><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><strong><code>$GOROOT</code></strong> Go的安装位置，默认<code>$HOME/go</code></p><p><strong><code>$GOBIN</code></strong> 编译器和链接器的安装位置，默认<code>$GOROOT/bin</code></p><p><strong><code>$GOPATH</code></strong> 默认采用<code>$GOROOT</code>，必须以下三个目录</p><ul><li><p><code>src</code> 源码文件</p></li><li><p><code>pkg</code> 包文件</p></li><li><p><code>bin</code> 可执行文件</p></li></ul><p><strong><code>$GOARCH</code></strong> 目标机器的处理器架构(386/amd64/arm)</p><p><strong><code>$GOOS</code></strong> 目标机器的操作系统(Darwin/freebsd/linux/windows)</p><p><strong><code>$GOHOSTARCH</code></strong> <strong><code>$GOHOSTOS</code></strong> 本地机器的处理器架构/操作系统（交叉编译时使用， 默认和目标机器一样）</p><p><strong><code>$GOARM</code></strong> 针对基于arm架构的处理器(5~7, 默认6)</p><p><strong><code>$GOMAXPROCS</code></strong> 设置应用程序可用的处理器个数和核数</p><h2 id="Go运行时"><a href="#Go运行时" class="headerlink" title="Go运行时"></a>Go运行时</h2><h2 id="Go解释器"><a href="#Go解释器" class="headerlink" title="Go解释器"></a>Go解释器</h2><h1 id="基本结构和基本数据类型"><a href="#基本结构和基本数据类型" class="headerlink" title="基本结构和基本数据类型"></a>基本结构和基本数据类型</h1><h1 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h1><h1 id="函数-function"><a href="#函数-function" class="headerlink" title="函数(function)"></a>函数(function)</h1><h1 id="数组与切片"><a href="#数组与切片" class="headerlink" title="数组与切片"></a>数组与切片</h1><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h1 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h1><h1 id="结构-struct-与方法-method"><a href="#结构-struct-与方法-method" class="headerlink" title="结构(struct)与方法(method)"></a>结构(struct)与方法(method)</h1><h1 id="接口-interface-与反射-reflection"><a href="#接口-interface-与反射-reflection" class="headerlink" title="接口(interface)与反射(reflection)"></a>接口(interface)与反射(reflection)</h1><h1 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h1><h1 id="错误处理与测试"><a href="#错误处理与测试" class="headerlink" title="错误处理与测试"></a>错误处理与测试</h1><h1 id="协程-goroutine-与通道-channel"><a href="#协程-goroutine-与通道-channel" class="headerlink" title="协程(goroutine)与通道(channel)"></a>协程(goroutine)与通道(channel)</h1><h1 id="网络，模版和网页应用"><a href="#网络，模版和网页应用" class="headerlink" title="网络，模版和网页应用"></a>网络，模版和网页应用</h1><h1 id="常见陷阱与错误"><a href="#常见陷阱与错误" class="headerlink" title="常见陷阱与错误"></a>常见陷阱与错误</h1><h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><h1 id="出于性能考虑的实用代码片段"><a href="#出于性能考虑的实用代码片段" class="headerlink" title="出于性能考虑的实用代码片段"></a>出于性能考虑的实用代码片段</h1><h1 id="构建完整的应用"><a href="#构建完整的应用" class="headerlink" title="构建完整的应用"></a>构建完整的应用</h1>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Go API</tag>
      
      <tag>Go实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang</title>
    <link href="/2021/02/19/Golang/"/>
    <url>/2021/02/19/Golang/</url>
    
    <content type="html"><![CDATA[<p>应用领域：</p><ol><li>区块链研发工程师</li><li>服务端/游戏工程师</li><li>分布式/云计算</li></ol><h1 id="概述及环境配置"><a href="#概述及环境配置" class="headerlink" title="概述及环境配置"></a>概述及环境配置</h1><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>核心开发团队：Ken/Rob/Robert</p><p>Google为什么开发Go?</p><ol><li>现有语言不能充分利用硬件（CPU）</li><li>现有语言不够简洁高效 （风格不统一，计算能力不够，并发不好）</li><li>c/c++编译慢、内存泄露等</li></ol><p>2009 Go1.0</p><p>2015 去除C</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Go = C + Python</p><ol><li>继承了C的很多理念</li><li>引入包，用于组织程序</li><li>垃圾回收</li><li><strong>天然并发</strong></li><li>管道通信</li></ol><h2 id="Go模组-GOPATH-GOROOT"><a href="#Go模组-GOPATH-GOROOT" class="headerlink" title="Go模组, GOPATH, GOROOT"></a>Go模组, GOPATH, GOROOT</h2><p>GOROOT: go的安装目录</p><p><strong>GOPATH</strong>: go项目的工作目录</p><ul><li>src存放源代码(.go .c .h .s)</li><li>pkg编译后的文件(.a)</li><li>bin可执行文件</li></ul><h3 id="Go-Module"><a href="#Go-Module" class="headerlink" title="Go Module"></a>Go Module</h3><p>fix: GOPATH</p><p><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/01.2.md">https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/01.2.md</a></p><h2 id="Go命令"><a href="#Go命令" class="headerlink" title="Go命令"></a>Go命令</h2><p><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/01.3.md">https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/01.3.md</a></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释是不会解析的纯文本（不要使用HTML）</p><p>文档注释：包中顶级声明上面的注释（无空行分隔）</p><ol><li><p>每个包应该有一段包注释</p></li><li><p>每个可导出名都应有注释</p></li></ol><h2 id="命名规则与分号"><a href="#命名规则与分号" class="headerlink" title="命名规则与分号"></a>命名规则与分号</h2><p>命名规则</p><ol><li><p>包名：一个小写单词（不应使用下划线和驼峰），且为源码的基本名称（encoding/base64 -&gt; base64）</p></li><li><p>Getters: <code>owenr</code> -&gt; <code>Owner</code>/<code>SetOwner</code></p></li><li><p>接口名：只包含一个方法的接口应当以该方法的名称加上 - er 后缀来命名</p></li><li><p>约定：驼峰命名</p></li></ol><p>分号不要写</p><blockquote><p>词法分析器规则：如果新行前的标记为语句的末尾，则插入分号</p></blockquote><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p><strong>特点</strong></p><ol><li>每个Go程序都属于一个包<code>package &lt;pkgName&gt;</code></li><li>包只会被导入一次</li><li><strong>包名与导入路径的最后一个元素一致</strong></li><li>(导入包后)<strong>只能引用导出名</strong><ol><li>大写字母开头的变量是可导出的，是公有变量；小写字母开头的是不可导出的，是私有变量</li><li>大写字母开头的函数相当于<code>class</code>中的<code>public</code>函数；小写字母开头的就是<code>private</code>函数</li></ol></li></ol><p><strong>导入</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 单一导入</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;math&quot;</span><br><br><span class="hljs-comment">// 分组导入(推荐)</span><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>  <span class="hljs-string">&quot;math&quot;</span><br>)<br></code></pre></td></tr></table></figure><p><strong>技巧</strong></p><p>点操作: 省略包名前缀</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span>(<br>  . <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br>Println(<span class="hljs-string">&quot;.&quot;</span>)<br></code></pre></td></tr></table></figure><p>别名操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span>(<br>  f <span class="hljs-string">&quot;fmt&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>_操作： 不使用包的函数，而是调用包的<code>init</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;database/sql&quot;</span><br>_ <span class="hljs-string">&quot;github.com/ziutek/mymysql/godrv&quot;</span><br>)<br></code></pre></td></tr></table></figure><h2 id="变量、常量"><a href="#变量、常量" class="headerlink" title="变量、常量"></a>变量、常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>特点</strong></p><ol><li><p>已声明但未使用的变量会在编译阶段报错</p></li><li><p><code>var</code>声明变量列表，类型在最后</p><p> <code>var</code>可出现在包/函数级别</p></li><li><p><strong>声明时可包含初始值，每个变量对应一个。有初始值则类型可省，没初始值则赋予零值</strong></p></li><li><p><strong>简短声明只能在函数内</strong></p><p> 函数外的每个语句必须以关键字开始</p></li><li><p><code>_</code><strong>舍弃值</strong></p><p> 是个特殊的变量名，任何赋予它的值都会被丢弃</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 常用案例</span><br>i := <span class="hljs-number">1</span><br><br><span class="hljs-keyword">var</span> (<br>j = <span class="hljs-number">2</span><br>  k = <span class="hljs-number">3</span><br>  d = <span class="hljs-number">4</span><br>)<br></code></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ol><li>const关键字</li><li>不能使用<code>:=</code></li><li><strong>一个未指定类型的常量由上下文来决定其类型</strong></li></ol><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><h4 id="分组声明"><a href="#分组声明" class="headerlink" title="分组声明"></a><strong>分组声明</strong></h4><p>声明多个常量、变量、导入多个包的简化语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span>(<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">const</span>(<br>i = <span class="hljs-number">100</span><br>pi = <span class="hljs-number">3.1415</span><br>prefix = <span class="hljs-string">&quot;Go_&quot;</span><br>)<br><br><span class="hljs-keyword">var</span>(<br>i <span class="hljs-keyword">int</span><br>pi <span class="hljs-keyword">float32</span><br>prefix <span class="hljs-keyword">string</span><br>)<br></code></pre></td></tr></table></figure><h4 id="iota枚举"><a href="#iota枚举" class="headerlink" title="iota枚举"></a>iota枚举</h4><p>关键字iota用来声明枚举，默认开始值为0，const中每增加一行加一</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>x = <span class="hljs-literal">iota</span> <span class="hljs-comment">// x == 0</span><br>y = <span class="hljs-literal">iota</span> <span class="hljs-comment">// y == 1</span><br>z = <span class="hljs-literal">iota</span> <span class="hljs-comment">// z == 2</span><br>w        <span class="hljs-comment">// 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用&quot;= iota&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> v = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 每遇到一个const关键字，iota就会重置，此时v == 0</span><br><br><span class="hljs-keyword">const</span> (<br>h, i, j = <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span> <span class="hljs-comment">//h=0,i=0,j=0 iota在同一行值相同</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>a       = <span class="hljs-literal">iota</span> <span class="hljs-comment">//a=0</span><br>b       = <span class="hljs-string">&quot;B&quot;</span><br>c       = <span class="hljs-literal">iota</span>             <span class="hljs-comment">//c=2</span><br>d, e, f = <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span> <span class="hljs-comment">//d=3,e=3,f=3</span><br>g       = <span class="hljs-literal">iota</span>             <span class="hljs-comment">//g = 4</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(a, b, c, d, e, f, g, h, i, j, x, y, z, w, v)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">bool</span><span class="hljs-comment">// true/false，零值false</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">string</span>  <span class="hljs-comment">// &quot;普通字符串&quot; `原始多行字符串`，不可变，零值&quot;&quot;</span><br><br><span class="hljs-comment">// 修改1</span><br>s := <span class="hljs-string">&quot;hello&quot;</span><br>c := []<span class="hljs-keyword">byte</span>(s)  <span class="hljs-comment">// 将字符串 s 转换为 []byte 类型</span><br>c[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;c&#x27;</span><br>s2 := <span class="hljs-keyword">string</span>(c)  <span class="hljs-comment">// 再转换回 string 类型</span><br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, s2)<br><br><span class="hljs-comment">// 修改2</span><br>s := <span class="hljs-string">&quot;hello&quot;</span><br>s = <span class="hljs-string">&quot;c&quot;</span> + s[<span class="hljs-number">1</span>:] <span class="hljs-comment">// 字符串虽不能更改，但可进行切片操作</span><br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, s)<br><br><span class="hljs-comment">// + 拼接</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">int</span>  <span class="hljs-keyword">int8</span>  <span class="hljs-keyword">int16</span>  <span class="hljs-keyword">int32</span>  <span class="hljs-keyword">int64</span><br><span class="hljs-keyword">uint</span> <span class="hljs-keyword">uint8</span> <span class="hljs-keyword">uint16</span> <span class="hljs-keyword">uint32</span> <span class="hljs-keyword">uint64</span> <span class="hljs-keyword">uintptr</span><br><br><span class="hljs-keyword">float32</span> <span class="hljs-keyword">float64</span><br><br><span class="hljs-keyword">complex64</span> <span class="hljs-keyword">complex128</span><br><br><span class="hljs-keyword">byte</span> <span class="hljs-comment">// uint8 的别名</span><br><span class="hljs-keyword">rune</span> <span class="hljs-comment">// int32 的别名</span><br>    <span class="hljs-comment">// 表示一个 Unicode 码点</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 当你需要一个整数值时应使用 int 类型，除非你有特殊的理由使用固定大小或无符号的整数类型</span><br><br><span class="hljs-comment">// 查看变量类型</span><br>fmt.Prinf(<span class="hljs-string">&quot;%T&quot;</span>, x)<br><span class="hljs-comment">// 查看变量占用字节数</span><br>unsafe.sizeof(x)<br></code></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><code>T(v)</code> <strong>不同类型之间需要显示转换</strong></p><h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>声明变量时不指定类型，类型由右值推导</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">42</span>           <span class="hljs-comment">// int</span><br>f := <span class="hljs-number">3.142</span>        <span class="hljs-comment">// float64</span><br>g := <span class="hljs-number">0.867</span> + <span class="hljs-number">0.5i</span> <span class="hljs-comment">// complex128</span><br></code></pre></td></tr></table></figure><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p><code>type typeName typeLiteral</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ages <span class="hljs-keyword">int</span><br><br><span class="hljs-keyword">type</span> money <span class="hljs-keyword">float32</span><br><br><span class="hljs-keyword">type</span> months <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span><br><br>m := months &#123;<br><span class="hljs-string">&quot;January&quot;</span>:<span class="hljs-number">31</span>,<br><span class="hljs-string">&quot;February&quot;</span>:<span class="hljs-number">28</span>,<br>...<br><span class="hljs-string">&quot;December&quot;</span>:<span class="hljs-number">31</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h3><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ol><li><p>指针保存值的内存地址</p></li><li><p><code>*T</code>是指向T类型值的指针, 零值<code>nil</code></p></li><li><p><code>&amp;</code>生成指向操作数的指针</p></li><li><p><code>*</code>表示指针指向的值</p></li></ol><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><ol><li><p>一组字段的容器</p></li><li><p><code>.</code>访问字段</p></li><li><p>指针可直接通过<code>.</code>访问字段</p></li><li><p>匿名字段实现字段继承， 最外层优先访问</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义</span><br><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>age <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">// 声明</span><br><span class="hljs-keyword">var</span> P person / P := <span class="hljs-built_in">new</span>(person) <br>P.name = <span class="hljs-string">&quot;Astaxie&quot;</span>  <br>P.age = <span class="hljs-number">25</span>  <br><br>P := person&#123;<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">25</span>&#125;<br><br>P := person&#123;age:<span class="hljs-number">24</span>, name:<span class="hljs-string">&quot;Tom&quot;</span>&#125;<br><br><span class="hljs-comment">// 匿名字段</span><br><span class="hljs-keyword">type</span> Human <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>age <span class="hljs-keyword">int</span><br>weight <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Human  <span class="hljs-comment">// 匿名字段，那么默认Student就包含了Human的所有字段</span><br>speciality <span class="hljs-keyword">string</span><br>&#125;<br><br>mark := Student&#123;Human&#123;<span class="hljs-string">&quot;Mark&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-number">120</span>&#125;, <span class="hljs-string">&quot;Computer Science&quot;</span>&#125;<br><br>mark.Human = Human&#123;<span class="hljs-string">&quot;Marcus&quot;</span>, <span class="hljs-number">55</span>, <span class="hljs-number">220</span>&#125;<br>mark.Human.age -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p><code>[n]T </code>: n个T类型值的数组</p><p><strong>特点</strong>：</p><ul><li>有序，长度固定</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明</span><br><span class="hljs-keyword">var</span> a [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span><br>nums := [<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>nums2 := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p><code>[]T</code>: 元素类型为T的切片，零值为nil（长度，容量为0，没有底层数组）</p><p><strong>特点</strong>：</p><ol><li>有序，长度不固定，引用类型</li><li>可从数组/切片中再次声明</li><li>切片并不存储数据，它仅是一个数组片段的描述，修改切片会修改底层数组</li><li>忽略上下界的默认行为</li><li>有长度和容量，长度&gt;容量会在运行时报错<ul><li>长度：元素个数 <code>len(s)</code></li><li>容量：从切片的第一个元素到底层数组末尾元素的个数 <code>cap(s)</code></li></ul></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明</span><br><span class="hljs-keyword">var</span> s []<span class="hljs-keyword">int</span><br>q := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>&#125;<br><br><span class="hljs-comment">// 从数组,切片创建</span><br>A[low:high:capacity]<br><br><br><span class="hljs-comment">// make创建</span><br>a := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>)<span class="hljs-comment">// len(a)=5</span><br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">// len(b)=0, cap(b)=5</span><br><br><span class="hljs-comment">// 追加元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">append</span><span class="hljs-params">(s []T, vs ...T)</span> []<span class="hljs-title">T</span></span><br><br><span class="hljs-comment">// 复制</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copy</span><span class="hljs-params">(dst, src []Type)</span> <span class="hljs-title">int</span></span><br></code></pre></td></tr></table></figure><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p><code>map[K]V</code>: K类型的键到V类型的值的映射, 零值nil（无键且不能添加键）</p><p><strong>特点</strong>：</p><ol><li>无序，长度不固定，引用类型</li><li>线程不安全(需要互斥锁)</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明</span><br><span class="hljs-keyword">var</span> strInt <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span> <span class="hljs-comment">// 该声明需要make进行初始化</span><br>m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[K]V)<br><br><span class="hljs-comment">//(若顶级类型只是一个类型名，你可以在文法的元素中省略它)</span><br><span class="hljs-keyword">map</span>[K]V&#123;<br>  k1: v1,<br>  ...<br>&#125;<br><br><span class="hljs-comment">// 插入，修改</span><br>m[key] = value<br><span class="hljs-comment">// 获取</span><br>m[key]<br><span class="hljs-comment">// 删除</span><br><span class="hljs-built_in">delete</span>(m, key)<br><span class="hljs-comment">// 成员检查（双赋值检测）</span><br>value, in = m[key]<br>in = <span class="hljs-literal">true</span>/<span class="hljs-literal">false</span><br>value = m[key]/<span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure><h4 id="技巧-1"><a href="#技巧-1" class="headerlink" title="技巧"></a>技巧</h4><h5 id="make-new"><a href="#make-new" class="headerlink" title="make, new"></a>make, new</h5><p><code>make</code>用于内建类型（<code>map</code>、<code>slice</code> 和<code>channel</code>）的内存分配</p><blockquote><p><code>make</code>返回初始化后的（非零）值</p><p>导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化</p></blockquote><p><code>new</code>用于各种类型的内存分配</p><blockquote><p><code>new</code>返回指针，指向类型<code>T</code>的零值</p></blockquote><h5 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h5><p>零值不是空值，而是一种”变量未填充前”的默认值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 部分零值</span><br><span class="hljs-keyword">int</span>     <span class="hljs-number">0</span><br><span class="hljs-keyword">int8</span>    <span class="hljs-number">0</span><br><span class="hljs-keyword">int32</span>   <span class="hljs-number">0</span><br><span class="hljs-keyword">int64</span>   <span class="hljs-number">0</span><br><span class="hljs-keyword">uint</span>    <span class="hljs-number">0x0</span><br><span class="hljs-keyword">rune</span>    <span class="hljs-number">0</span> <span class="hljs-comment">//rune的实际类型是 int32</span><br><span class="hljs-keyword">byte</span>    <span class="hljs-number">0x0</span> <span class="hljs-comment">// byte的实际类型是 uint8</span><br><span class="hljs-keyword">float32</span> <span class="hljs-number">0</span> <span class="hljs-comment">//长度为 4 byte</span><br><span class="hljs-keyword">float64</span> <span class="hljs-number">0</span> <span class="hljs-comment">//长度为 8 byte</span><br><span class="hljs-keyword">bool</span>    <span class="hljs-literal">false</span><br><span class="hljs-keyword">string</span>  <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>组成部分：</p><ol><li>初始化语句：第一次迭代前执行</li><li>条件表达式：每次迭代前求值</li><li>后置语句：每次迭代的结尾执行</li></ol><p>特点：</p><ol><li>循环变量仅在for的作用域可见</li><li>初始化语句和后置语句可选</li><li>省略循环条件，则死循环</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>sum += i<br>&#125;<br>fmt.Println(sum)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="break-continue"><a href="#break-continue" class="headerlink" title="break, continue"></a>break, continue</h4><p><code>break</code>结束循环</p><p><code>continue</code>跳过当前迭代</p><p>可跟标签</p><h4 id="range"><a href="#range" class="headerlink" title="range"></a>range</h4><p><code>for</code>配合<code>range</code>可遍历<code>slice</code>, <code>map</code>,<code>string</code>, <code>chan</code></p><p><strong>省2不写，省一空白</strong></p><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>条件判断语句可声明变量， 该变量可在if/else if/else中使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> integer == <span class="hljs-number">3</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;== 3&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> integer &lt; <span class="hljs-number">3</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;&lt; 3&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;&gt; 3&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><ol><li>可声明变量</li><li>自带<code>break</code>，除非<code>fallthrough</code></li><li><code>case</code>可通过逗号分隔相同处理的条件</li><li><code>case</code>从上而下求值</li><li>无条件<code>switch</code>同<code>switch true</code>代替<code>if-else if-else</code></li></ol><h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><ol><li>跳转到当前函数内定义的标签</li><li>标签名大小写敏感</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">0</span><br>Here:   <span class="hljs-comment">//这行的第一个词，以冒号结束作为标签</span><br><span class="hljs-built_in">println</span>(i)<br>i++<br><span class="hljs-keyword">goto</span> Here   <span class="hljs-comment">//跳转到Here去</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><ol><li><p>将函数调用推迟到外层函数返回后执行</p></li><li><p>参数会立即求值</p></li><li><p>defer栈</p></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>参数</strong></p><ol><li><p>接受无参、单参、多参</p></li><li><p>变参<code>...T</code> (本质是<code>slice</code>)</p></li><li><p>参数列表类型省略<code>x, y int</code></p></li></ol><blockquote><p>传值和传指针</p><p>传一个参数值给函数时，实际上是传了这个值的一份拷贝</p><p>传指针的好处：</p><p>​    1. 使得多个函数可操作同一对象</p><p>​    2. 轻量级(8字节)， 只是传内存地址</p><p>​    3. <code>slice</code>, <code>map</code>, <code>channel</code>实现机制类似指针，可直接传递，无需取地址（注：若函数需改变<code>slice</code>的长度，则仍需要取地址传递指针）</p></blockquote><p><strong>返回值</strong></p><ol><li><p>多值返回（eg: 减少指针传入）</p></li><li><p>命名返回值</p><blockquote><p>函数开始执行则初始化为零值</p><p>空<code>return</code>返回</p></blockquote></li></ol><p><strong>函数作为值、类型</strong></p><ol><li>函数是值，可以作为参数和返回值</li><li>闭包(返回保存了外层函数的变量的函数)</li><li>函数是变量， 它的类型就是所有拥有相同的参数，相同的返回值的一种类型<code>type typeName func(...) </code></li></ol><h3 id="panic和recover函数"><a href="#panic和recover函数" class="headerlink" title="panic和recover函数"></a>panic和recover函数</h3><p><code>panic</code>中断当前控制流程，进入<code>panic</code>状态</p><blockquote><p><code>F</code>调用<code>panic</code>，<code>F</code>中断执行，但<code>defer</code>函数正常执行，然后返回调用<code>F</code>的地方，接着<code>panic</code>会向上传递，直到发送<code>panic</code>的<code>goroutine</code>中所有调用的函数返回，此时程序退出。</p></blockquote><p><code>recover</code>恢复进入<code>panic</code>的<code>goroutine</code></p><blockquote><p><code>recover</code>仅在<code>defer</code>函数中有效</p><p>正常情况下<code>recover</code>返回<code>nil</code></p><p><code>recover</code>可以获得<code>panic</code>的输入值，并恢复正常执行</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> x := <span class="hljs-built_in">recover</span>(); x != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// recover and process</span><br>&#125;<br>&#125;()<br><br><span class="hljs-comment">// normal process</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="main和init函数"><a href="#main和init函数" class="headerlink" title="main和init函数"></a>main和init函数</h3><p>相同点：</p><ol><li>无参无返回值</li><li>Go会自动调用</li></ol><p>不同点：</p><ol><li><code>main</code>只能作用于<code>main</code>包, <code>init</code>可作用于所有包</li><li><code>main</code>包必须有一个<code>main</code>，包中可有任意个<code>init</code>(推荐一个)</li></ol><p><strong>main函数引入包的初始化流程</strong></p><p><img src="/img/2.3.init.png"></p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>定义：带 <strong>接收者</strong> 的函数</p><ol><li><p>接收者的类型定义和方法声明必须在同一包内</p></li><li><p>接收者不能为内建类型， 可通过<code>type</code>绕过</p></li><li><p>指针接收者直接操作对象内容（推荐）</p></li><li><p>指针重定向</p><blockquote><p>*T    V.method &lt;=&gt; (&amp;V).method</p><p>T     P.method &lt;=&gt; (*P).method</p></blockquote></li></ol><p><strong>继承</strong>：匿名字段</p><p><strong>重写</strong>：同名方法</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p><strong>接口</strong>：一组方法签名</p><p><strong>接口类型</strong>：定义了一组方法，如果某个对象实现了某个接口的所有方法，该对象就实现了该接口</p><p><strong>接口变量</strong>：接口变量可以存储任何实现该接口的对象</p><p><strong>接口参数</strong>：让函数接受实现该接口的对象</p><p><strong>空接口</strong><code>interface &#123;&#125;</code>：所有的类型都实现了空接口, 用于存储任意类型的值</p><p><strong>接口变量存储的类型</strong></p><ul><li><p>comma-ok断言</p><blockquote><p><code> value, ok = element.(T)</code>如果element存储了T类型的数值，那么ok为true，否则false</p></blockquote></li><li><p>switch测试</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> v := i.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> T:<br>    <span class="hljs-comment">// v 的类型为 T</span><br><span class="hljs-keyword">case</span> S:<br>    <span class="hljs-comment">// v 的类型为 S</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 没有匹配，v 与 i 的类型相同</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>嵌入接口</strong>: 隐式包含方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// io.ReadWriter</span><br><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;<br>Reader<br>Writer<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>常见接口</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// fmt.Stringer</span><br><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;<br>  String() <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// builtins</span><br><span class="hljs-comment">// 模拟错误</span><br><span class="hljs-keyword">type</span> error <span class="hljs-keyword">interface</span> &#123;<br>  Error() <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">// 错误处理工具包errors</span><br>err := errors.New(<span class="hljs-string">&quot;some error&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Print(err)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// io.Reader</span><br><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;<br>Read(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>检查程序运行时状态的能力</p><p><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/02.6.md">https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/02.6.md</a></p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p><strong>Go的runtime管理的一个线程管理器</strong></p><p><code>go fn(x)</code>会启动一个<code>goroutine</code>并执行<code>fn(x)</code></p><ol><li><code>fn</code> ,<code>x</code>的求值在当前<code>goroutine</code>，<code>fn</code>执行在新<code>goroutine</code></li><li>多个<code>goroutine</code>运行在同一个进程里面，共享内存数据</li></ol><h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><p><strong>带有类型的管道， 用于goroutine间的通信</strong></p><p>必须通过<code>make</code>创建: <code>ch := make(chan int)</code> </p><p><code>&lt;-</code>操作符</p><ul><li><code>ch &lt;- v</code> 发送值到信道</li><li><code>v := &lt;-ch</code> 从信道接受值</li></ul><p><strong>特点</strong>：</p><ol><li>无缓冲信道发送、接受操作会阻塞（使得Go在没有显示锁或竞态变量的情况下保证同步）</li><li>信道可以带缓冲（仅当缓冲器满，向其发送值才会阻塞，仅当缓冲区为空，从其接受值才会阻塞）</li></ol><p><strong>range和close</strong></p><p><code>for i := range c</code>能够不断的读取信道里面的数据，直到该信道被显式的关闭</p><p><code>v, ok := &lt;-ch</code>可测试信道是否关闭</p><p>生产者关闭信道， 而不是消费值</p><p>信道无需像文件一样经常关闭，只有当无数据可发，或显示结束range时才</p><p><strong>select</strong>: 监听多个信道的数据流动</p><ol><li>默认阻塞，直到有信道有数据流动</li><li>当多个信道有数据流动，则随机执行</li><li>当所有信道都没有数据流动，<code>default</code> 就执行</li></ol><p><strong>超时技巧</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>o := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> v := &lt;- c:<br><span class="hljs-built_in">println</span>(v)<br><span class="hljs-keyword">case</span> &lt;- time.After(<span class="hljs-number">5</span> * time.Second):<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;timeout&quot;</span>)<br>o &lt;- <span class="hljs-literal">true</span><br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;()<br>&lt;- o<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>runtime包处理goroutine的函数</strong></p><ul><li><p>Goexit</p><p>  退出当前执行的goroutine，但是defer函数还会继续调用</p></li><li><p>Gosched</p><p>  让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。</p></li><li><p>NumCPU</p><p>  返回 CPU 核数量</p></li><li><p>NumGoroutine</p><p>  返回正在执行和排队的任务总数</p></li><li><p>GOMAXPROCS</p><p>  用来设置可以并行计算的CPU核数的最大值，并返回之前的值。</p></li></ul><h2 id="互斥锁（sync-Mutex）"><a href="#互斥锁（sync-Mutex）" class="headerlink" title="互斥锁（sync.Mutex）"></a>互斥锁（sync.Mutex）</h2><p>方法</p><ul><li><code>Lock</code></li><li><code>Unlock</code> 用<code>defer</code>保证一定解锁</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-comment">// 异步爬虫</span><br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Fetcher <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Fetch 返回 URL 的 body 内容，并且将在这个页面上找到的 URL 放到一个 slice 中。</span><br>Fetch(url <span class="hljs-keyword">string</span>) (body <span class="hljs-keyword">string</span>, urls []<span class="hljs-keyword">string</span>, err error)<br>&#125;<br><br><span class="hljs-keyword">type</span> Record <span class="hljs-keyword">struct</span> &#123;<br>v     <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span><br>mutex sync.Mutex<br>group sync.WaitGroup<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Record)</span> <span class="hljs-title">repeat</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>r.mutex.Lock()<br><span class="hljs-keyword">defer</span> r.mutex.Unlock()<br><span class="hljs-keyword">if</span> _, in := r.v[url]; in &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>r.v[url] = <span class="hljs-literal">true</span><br>r.group.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">var</span> record = Record&#123;v: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span>)&#125;<br><br><span class="hljs-comment">// Crawl 使用 fetcher 从某个 URL 开始递归的爬取页面，直到达到最大深度。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Crawl</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>, depth <span class="hljs-keyword">int</span>, fetcher Fetcher)</span></span> &#123;<br><span class="hljs-keyword">defer</span> record.group.Done()<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 并行的抓取 URL。</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 不重复抓取页面。</span><br><span class="hljs-comment">// 下面并没有实现上面两种情况：</span><br><span class="hljs-keyword">if</span> depth &lt;= <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>body, urls, err := fetcher.Fetch(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;found: %s %q\n&quot;</span>, url, body)<br><span class="hljs-keyword">for</span> _, u := <span class="hljs-keyword">range</span> urls &#123;<br><span class="hljs-keyword">if</span> !record.repeat(u) &#123;<br><span class="hljs-keyword">go</span> Crawl(u, depth<span class="hljs-number">-1</span>, fetcher)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> url = <span class="hljs-string">&quot;https://golang.org/&quot;</span><br>record.repeat(url)<br>Crawl(url, <span class="hljs-number">4</span>, fetcher)<br>record.group.Wait()<br>&#125;<br><br><span class="hljs-comment">// fakeFetcher 是返回若干结果的 Fetcher。</span><br><span class="hljs-keyword">type</span> fakeFetcher <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*fakeResult<br><br><span class="hljs-keyword">type</span> fakeResult <span class="hljs-keyword">struct</span> &#123;<br>body <span class="hljs-keyword">string</span><br>urls []<span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f fakeFetcher)</span> <span class="hljs-title">Fetch</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, []<span class="hljs-keyword">string</span>, error)</span></span> &#123;<br><span class="hljs-keyword">if</span> res, ok := f[url]; ok &#123;<br><span class="hljs-keyword">return</span> res.body, res.urls, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;not found: %s&quot;</span>, url)<br>&#125;<br><br><span class="hljs-comment">// fetcher 是填充后的 fakeFetcher。</span><br><span class="hljs-keyword">var</span> fetcher = fakeFetcher&#123;<br><span class="hljs-string">&quot;https://golang.org/&quot;</span>: &amp;fakeResult&#123;<br><span class="hljs-string">&quot;The Go Programming Language&quot;</span>,<br>[]<span class="hljs-keyword">string</span>&#123;<br><span class="hljs-string">&quot;https://golang.org/pkg/&quot;</span>,<br><span class="hljs-string">&quot;https://golang.org/cmd/&quot;</span>,<br>&#125;,<br>&#125;,<br><span class="hljs-string">&quot;https://golang.org/pkg/&quot;</span>: &amp;fakeResult&#123;<br><span class="hljs-string">&quot;Packages&quot;</span>,<br>[]<span class="hljs-keyword">string</span>&#123;<br><span class="hljs-string">&quot;https://golang.org/&quot;</span>,<br><span class="hljs-string">&quot;https://golang.org/cmd/&quot;</span>,<br><span class="hljs-string">&quot;https://golang.org/pkg/fmt/&quot;</span>,<br><span class="hljs-string">&quot;https://golang.org/pkg/os/&quot;</span>,<br>&#125;,<br>&#125;,<br><span class="hljs-string">&quot;https://golang.org/pkg/fmt/&quot;</span>: &amp;fakeResult&#123;<br><span class="hljs-string">&quot;Package fmt&quot;</span>,<br>[]<span class="hljs-keyword">string</span>&#123;<br><span class="hljs-string">&quot;https://golang.org/&quot;</span>,<br><span class="hljs-string">&quot;https://golang.org/pkg/&quot;</span>,<br>&#125;,<br>&#125;,<br><span class="hljs-string">&quot;https://golang.org/pkg/os/&quot;</span>: &amp;fakeResult&#123;<br><span class="hljs-string">&quot;Package os&quot;</span>,<br>[]<span class="hljs-keyword">string</span>&#123;<br><span class="hljs-string">&quot;https://golang.org/&quot;</span>,<br><span class="hljs-string">&quot;https://golang.org/pkg/&quot;</span>,<br>&#125;,<br>&#125;,<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/02/13/hello-world/"/>
    <url>/2021/02/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
